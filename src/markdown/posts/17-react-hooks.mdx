---
slug: 17-react-hooks
title: Comprendre les React Hooks pour mieux les utiiser
coverImage: /posts/17/cover.jpg
calendarDay: 17
category: Frontend
---

Disponibles depuis 2018 dans la version 16.8, les **Hooks** sont une grande r√©volution dans le monde des d√©velppeur‚Ä¢euse‚Ä¢s React. Ils permettent enfin de se d√©barasser des classes (je ne rentrerai pas dans les d√©tails de pourquoi c'est une h√©r√©sie, [d'autres l'ont bien fait](https://everyday.codes/javascript/please-stop-using-classes-in-javascript/) avant moi).

```jsx
const Counter = () => {
  const [value, setValue] = useState(0)
  return (
    <div>
      <button
        aria-label="Decrease"
        onClick={() => {
          setValue(value - 1)
        }}
      >
        -
      </button>
      <div>{value}</div>
      <button
        aria-label="Increase"
        onClick={() => {
          setValue(value + 1)
        }}
      >
        +
      </button>
    </div>
  )
}
```

De prime abord, √ßa parrait quand m√™me assez magique. Qu'est-ce qui se passe dans `useState` pour renvoyer une valeur et son setter, qui lui m√™me va provoquer un re-rendu du composant... Avec un oeil ext√©rieur, √ßa peut faire des noeuds au cerveau. Les hooks sont fait pour √™tre garants de l'ensemble des donn√©es et comportements de l'application, on comprend alors que s'il sont mal utilis√©s, il peuvent √™tre source de bugs, sous-performances, code spaguetti... üçù

Il est donc de la responsabilit√© de chaque d√©velopeur‚Ä¢euse de se renseigner sur comment les hooks fonctionnent avec React et comment les utiliser correctement pour cr√©er un code de qualit√©. Voici quelques pistes pour creuser le sujet :

## 1. Comprendre comment les hooks marchent

Pour r√©pondre √† ce genre de question, on commencera par aller chercher du c√¥t√© de la [documentation officielle de React](https://reactjs.org/docs/hooks-intro.html). Ces derni√®res ann√©es, elle a √©t√© bien √©toff√©e et elle est √† pr√©sent un v√©ritable point d'entr√©e quand on souhaite monter en comp√©tence sur React, gr√¢ce au partage de bonnes ou mauvaises pratiques, aux motivations intrins√®ques de certaines fonctionalit√©s... En somme c'est plus un manuel d'utilisation qu'une documentation.

Mais le c√¥t√© mystique des hooks persiste un peu. Alors pour comprendre un peu plus ce qui se passe sous le capot, j'avais vraiment ador√© la premi√®re partie de cette vid√©o, o√π [Ryan Florence](https://twitter.com/ryanflorence) re-d√©veloppe from scratch et avec humour la fonction useState.

<iframe
  width="560"
  height="315"
  src="https://www.youtube-nocookie.com/embed/1jWS7cCuUXw"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
  allowFullScreen
></iframe>

## 2. D√©couvrir les hooks avanc√©s

Une fois que les hooks principaux (useState, useEffect) sont assimil√©s, on peut commencer √† les int√©grer au sein d'app nouvelles ou existantes : les hooks √©tant compatibles avec les class, il est possible que ces deux fa√ßon de concevoir des composants React vivent au sein d'une m√™me app.

Cependant, m√™me s'ils pourraient presque se suffir, utiliser seulement useEffect et useState va irr√©m√©diablement faire tendre votre code vers un gros ramassi de spaguetti alors que c'est exactement ce qu'on voulait √©viter √† l'origine. On ira donc ensuite creuser parmi les hooks avanc√©s propos√©s nativement par React

- **useReducer** offre un pattern similaire √† celui propos√© par Redux, mais √† l'√©chelle du composant cette fois et non plus √† l'√©chelle de l'app compl√®te, ce qui r√©duit les chances de faire de votre state un monstre tantaculaire.
- **useMemo** qui permet de garder en m√©moire le r√©sultat d'op√©ration complexe et/ou couteuses (ex : tri de tableau) pour ne pas les rejouer √† chaque re-rendu.
- **useContext** pour lire un Contexte (cf: [Context API](https://reactjs.org/docs/context.html)) et s'abonner √† ses chagements.
- ... et encore d'autres qu'on retrouvera dans la [doc](https://reactjs.org/docs/hooks-reference.html#additional-hooks)

## 3. Cr√©er ses propres hooks pour s√©parer les responsabilit√©s

On dit traditionellement que **les composants sont pour l'affichage et les hooks sont pour le comportement**, mais il n'y a pas de r√®gle absolu et rien n'emp√™che un‚Ä¢e d√©velopeur‚Ä¢euse de cr√©er de nombreux hooks interd√©pendants au sein d'un m√™me comosants. C'est donc √† chacun de coder en bonne intelligence: c'est ok de stocker le state d'un Toggle, mais c'est pas ok de g√©rer les √©tats d'un formulaire multi-step au sein d'un seul composant. Pour ce genre ce cas d'usage, on peut externaliser la logique dans un hook personnalis√©.

Un hook personnalis√© est une fonction externe au composant (et donc dans un fichier diff√©rent ! üëÆ‚Äç‚ôÇÔ∏è) qui pourra appeller d'autres hooks. Par convention cette fonction commencera par use*YourImagination*... et c'est pas plus dur que √ßa ! Alors si vous commencez √† avoir 2-3 hooks qui ont des effets crois√©s, n'h√©sitez plus √† cr√©er votre propre hooks.

Personellement, c'est une pratique que j'applique depuis peu mais dont j'ai tr√®s vite vu les b√©n√©fices pour la construction d'un code plus lisble et plus maintenable. La prochaine √©tape sera de maitriser les test unitaires sur ces hooks personnalis√©s.

<iframe
  width="560"
  height="315"
  src="https://www.youtube-nocookie.com/embed/9lkZ77m-39I"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
  allowFullScreen
></iframe>
